<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        form {
  font: 1em sans-serif;
  max-width: 320px;
}

p > label {
  display: block;
}

input[type="text"],
input[type="email"],
input[type="number"],
textarea,
fieldset {
  width: 100%;
  border: 1px solid #333;
  box-sizing: border-box;
}

input:invalid {
  box-shadow: 0 0 5px 1px red;
}

input:focus:invalid {
  box-shadow: none;
}
    </style>
</head>
<body>
    <H2>reading assignment</H2>
    <ul>
        <li> Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away. If it gets to the server and is then rejected, a noticeable delay is caused by a round trip to the server and then back to the client-side to tell the user to fix their data.</li>
        <li>form validation. When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application. Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation. </li>
        <li>three reasosn for validating forms</li>
        <li>We want to get the right data, in the right format. Our applications won't work properly if our users' data is stored in the wrong format, is incorrect, or is omitted altogether.</li>
        <li>We want to protect our users' data. Forcing our users to enter secure passwords makes it easier to protect their account information.</li>
        <li>We want to protect ourselves. There are many ways that malicious users can misuse unprotected forms to damage the application. See</li>
        <li>warning:Never trust data passed to your server from the client. Even if your form is validating correctly and preventing malformed input on the client-side, a malicious user can still alter the network request.</li>
        <li>Different types of client-side validation</li>
        <li>Built-in form validation uses HTML form validation features, which we've discussed in many places throughout this module. This validation generally doesn't require much JavaScript. Built-in form validation has better performance than JavaScript, but it is not as customizable as JavaScript validation.</li>
        <li>JavaScript validation is coded using JavaScript. This validation is completely customizable, but you need to create it all (or use a library).</li>
        <li>there are four in-built form validation, inputs in HTML:</li>
        <li>required: Specifies whether a form field needs to be filled in before the form can be submitted.</li>
        <li>minlength and maxlength: Specifies the minimum and maximum length of textual data (strings).</li>
        <li>min and max: Specifies the minimum and maximum values of numerical input types.</li>
        <li>type: Specifies whether the data needs to be a number, an email address, or some other specific preset type.</li>
        <li>pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.</li>
        <li>For good user experience, indicate to the user when form fields are required. It isn't only good user experience, it is required by WCAG accessibility guidelines. Also, only require users to input data you actually need: For example, why do you really need to know someone's gender or title?</li>
        <li>Some <input> element types don't need a pattern attribute to be validated against a regular expression. Specifying the email type, for example, validates the inputs value against a well-formed email address pattern or a pattern matching a comma-separated list of email addresses if it has the multiple attribute.Note: The <textarea> element doesn't support the pattern attribute.</li>
        <li></li>
    </ul>
   
</body>
</html>